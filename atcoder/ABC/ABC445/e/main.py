from collections import defaultdict


# ============================================
# 最小素因数 (Smallest Prime Factor) を作る
# spf[x] = x の最小の素因数
# 例: 12 -> 2, 15 -> 3
#
# これを作っておくと、
# 各数の素因数分解が O(log A) でできる
# ============================================
def build_spf(n):
    spf = [0] * (n + 1)
    for i in range(2, n + 1):
        if spf[i] == 0:  # まだ未確定 → i は素数
            spf[i] = i
            for j in range(i * i, n + 1, i):
                if spf[j] == 0:  # まだ最小素因数が未確定
                    spf[j] = i
    return spf


# ============================================
# 拡張ユークリッドによる逆元
# a^{-1} mod m を求める
#
# 今回 MOD = 素数 なので、
# pow(a, MOD-2, MOD) でもOK
# ============================================
def modinv(a, m):
    b, u, v = m, 1, 0
    while b:
        t = a // b
        a -= t * b
        a, b = b, a
        u -= t * v
        u, v = v, u
    u %= m
    if u < 0:
        u += m
    return u


# ============================================
# 事前に spf を作る
# A[i] ≤ 10^7 なのでそこまで前計算
# ============================================
spf = build_spf(10**7)

T = int(input())
MOD = 998244353

for _ in range(T):
    N = int(input())
    A = list(map(int, input().split()))

    # ------------------------------------------------
    # e_1[p] : 素数 p の最大指数
    # e_2[p] : 2番目に大きい指数
    #
    # LCMを求めるとき必要なのは
    # 「最大」と「2番目」だけ
    # ------------------------------------------------
    e_1 = defaultdict(int)
    e_2 = defaultdict(int)

    # ------------------------------------------------
    # 各 A[i] を素因数分解して
    # 最大指数と2番目指数を更新
    # ------------------------------------------------
    for i in range(N):
        x = A[i]

        while x > 1:
            p = spf[x]  # 最小素因数
            e = 0

            # p の指数を数える
            while x % p == 0:
                x //= p
                e += 1

            # 最大・2番目更新
            if e > e_1[p]:
                e_2[p] = e_1[p]
                e_1[p] = e
            elif e > e_2[p]:
                e_2[p] = e

    # ------------------------------------------------
    # 全体LCMを一度計算
    #
    # LCM = ∏ p^{e_1[p]}
    # ------------------------------------------------
    lcm = 1
    for p in e_1:
        lcm *= pow(p, e_1[p], MOD)
        lcm %= MOD

    ret = []

    # ------------------------------------------------
    # 各 A[i] を除いた LCM を計算
    #
    # ポイント：
    # もし A[i] が
    # その素数 p の最大指数を
    # 唯一支えているなら
    # 指数を e_2[p] に下げる必要がある
    # ------------------------------------------------
    for i in range(N):
        lk = lcm
        x = A[i]

        while x > 1:
            p = spf[x]
            e = 0

            while x % p == 0:
                x //= p
                e += 1

            # この数が最大指数を支えている場合
            if e == e_1[p]:
                # 下げる分の指数差
                diff = e_1[p] - e_2[p]

                # p^diff で割る
                # mod なので逆元をかける
                divisor = pow(p, diff, MOD)

                lk *= modinv(divisor, MOD)
                lk %= MOD

        ret.append(lk)

    print(*ret)
