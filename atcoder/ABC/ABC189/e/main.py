# -----------------------------------------
# 3×3 行列の掛け算
# C = A × B
# -----------------------------------------
def mat_mul(A, B):
    C = [[0] * 3 for _ in range(3)]
    for i in range(3):
        for j in range(3):
            C[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j] + A[i][2] * B[2][j]
    return C


# -----------------------------------------
# 行列を点 (x, y) に適用
# -----------------------------------------
def apply(M, x, y):
    nx = M[0][0] * x + M[0][1] * y + M[0][2]
    ny = M[1][0] * x + M[1][1] * y + M[1][2]
    return nx, ny


# -----------------------------------------
# メイン処理
# -----------------------------------------

N = int(input())
P = [tuple(map(int, input().split())) for _ in range(N)]

M = int(input())

# T[i] = i 回操作した後の変換行列
# 初期状態は単位行列
T = [[[1, 0, 0], [0, 1, 0], [0, 0, 1]]]

for _ in range(M):
    op = list(map(int, input().split()))

    # 今の累積行列
    A = T[-1]

    # 新しい操作の行列 B を作る
    if op[0] == 1:
        # 90度時計回り：(x, y) → (y, -x)
        B = [[0, 1, 0], [-1, 0, 0], [0, 0, 1]]
    elif op[0] == 2:
        # 90度反時計回り：(x, y) → (-y, x)
        B = [[0, -1, 0], [1, 0, 0], [0, 0, 1]]
    elif op[0] == 3:
        # x = p で反転：(x, y) → (2p - x, y)
        p = op[1]
        B = [[-1, 0, 2 * p], [0, 1, 0], [0, 0, 1]]
    else:  # op[0] == 4
        # y = p で反転：(x, y) → (x, 2p - y)
        p = op[1]
        B = [[1, 0, 0], [0, -1, 2 * p], [0, 0, 1]]

    # 新しい累積行列 = B × A
    T.append(mat_mul(B, A))


Q = int(input())
for _ in range(Q):
    a, b = map(int, input().split())
    x, y = P[b - 1]

    # 操作 a 回後の変換行列 T[a] を適用
    nx, ny = apply(T[a], x, y)
    print(nx, ny)
