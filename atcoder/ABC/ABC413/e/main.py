def solve():
    _ = int(input())  # N: 配列のサイズは 2^N
    P = list(map(int, input().split()))  # 順列 P（0-indexed or 1-indexedどちらでもOK）

    # ------------------------------------------------------------
    # 再帰関数：長さが 2^k の部分配列を最適化して返す
    # ------------------------------------------------------------
    def dfs(arr):
        # 要素が1つなら、そのまま返す（これ以上操作できない）
        if len(arr) == 1:
            return arr

        half = len(arr) // 2
        left = dfs(arr[:half])  # 左半分を最適化
        right = dfs(arr[half:])  # 右半分を最適化

        # --------------------------------------------------------
        # 操作「反転」はこのスケールでは「左右ブロックを入れ替える」ことに相当
        # よって、左右のどちらを前に置くかで辞書順が変わる
        # --------------------------------------------------------
        if left + right <= right + left:
            return left + right
        else:
            return right + left

    ans = dfs(P)
    print(*ans)


# ============================================================
# 複数テストケースに対応
# ============================================================
T = int(input())
for _ in range(T):
    solve()
